diff --git nova/tests/unit/virt/libvirt/volume/test_quobyte.py nova/tests/unit/virt/libvirt/volume/test_quobyte.py
index a43a79a..7f867fa 100644
--- nova/tests/unit/virt/libvirt/volume/test_quobyte.py
+++ nova/tests/unit/virt/libvirt/volume/test_quobyte.py
@@ -15,12 +15,15 @@
 """Unit tests for the Quobyte volume driver module."""
 
 import os
+import traceback
 
 import mock
 from oslo_concurrency import processutils
 from oslo_utils import fileutils
+import psutil
+import six
 
-from nova import exception
+from nova import exception as nova_exception
 from nova import test
 from nova.tests.unit.virt.libvirt.volume import test_volume
 from nova import utils
@@ -31,9 +34,37 @@ from nova.virt.libvirt.volume import quobyte
 class QuobyteTestCase(test.NoDBTestCase):
     """Tests the nova.virt.libvirt.volume.quobyte module utilities."""
 
+    TEST_MNT_POINT = mock.sentinel.TEST_MNT_POINT
+
+    def assertRaisesAndMessageMatches(
+            self, excClass, msg, callableObj, *args, **kwargs):
+        """Ensure that the specified exception was raised. """
+
+        caught = False
+        try:
+            callableObj(*args, **kwargs)
+        except Exception as exc:
+            caught = True
+            self.assertIsInstance(exc, excClass,
+                                  'Wrong exception caught: %s Stacktrace: %s' %
+                                  (exc, traceback.format_exc()))
+            self.assertIn(msg, six.text_type(exc))
+
+        if not caught:
+            self.fail('Expected raised exception but nothing caught.')
+
+    def get_mock_partitions(self):
+        mypart = mock.Mock()
+        mypart.device = "quobyte@"
+        mypart.mountpoint = self.TEST_MNT_POINT
+        return [mypart]
+
+    @mock.patch.object(os.path, "exists", return_value=False)
     @mock.patch.object(fileutils, "ensure_tree")
     @mock.patch.object(utils, "execute")
-    def test_quobyte_mount_volume(self, mock_execute, mock_ensure_tree):
+    def test_quobyte_mount_volume_not_systemd(self, mock_execute,
+                                              mock_ensure_tree,
+                                              mock_exists):
         mnt_base = '/mnt'
         quobyte_volume = '192.168.1.1/volume-00001'
         export_mnt_base = os.path.join(mnt_base,
@@ -43,17 +74,45 @@ class QuobyteTestCase(test.NoDBTestCase):
 
         mock_ensure_tree.assert_called_once_with(export_mnt_base)
         expected_commands = [mock.call('mount.quobyte',
+                                       '--disable-xattrs',
                                        quobyte_volume,
-                                       export_mnt_base,
-                                       check_exit_code=[0, 4])
+                                       export_mnt_base)
+                             ]
+        mock_execute.assert_has_calls(expected_commands)
+        mock_exists.assert_called_once_with(" /run/systemd/system")
+
+    @mock.patch.object(os.path, "exists", return_value=True)
+    @mock.patch.object(fileutils, "ensure_tree")
+    @mock.patch.object(utils, "execute")
+    def test_quobyte_mount_volume_systemd(self, mock_execute,
+                                          mock_ensure_tree,
+                                          mock_exists):
+        mnt_base = '/mnt'
+        quobyte_volume = '192.168.1.1/volume-00001'
+        export_mnt_base = os.path.join(mnt_base,
+                                       utils.get_hash_str(quobyte_volume))
+
+        quobyte.mount_volume(quobyte_volume, export_mnt_base)
+
+        mock_ensure_tree.assert_called_once_with(export_mnt_base)
+        expected_commands = [mock.call('systemd-run',
+                                       '--scope',
+                                       '--user',
+                                       'mount.quobyte',
+                                       '--disable-xattrs',
+                                       quobyte_volume,
+                                       export_mnt_base)
                              ]
         mock_execute.assert_has_calls(expected_commands)
+        mock_exists.assert_called_once_with(" /run/systemd/system")
 
+    @mock.patch.object(os.path, "exists", return_value=False)
     @mock.patch.object(fileutils, "ensure_tree")
     @mock.patch.object(utils, "execute")
     def test_quobyte_mount_volume_with_config(self,
                                               mock_execute,
-                                              mock_ensure_tree):
+                                              mock_ensure_tree,
+                                              mock_exists):
         mnt_base = '/mnt'
         quobyte_volume = '192.168.1.1/volume-00001'
         export_mnt_base = os.path.join(mnt_base,
@@ -66,13 +125,14 @@ class QuobyteTestCase(test.NoDBTestCase):
 
         mock_ensure_tree.assert_called_once_with(export_mnt_base)
         expected_commands = [mock.call('mount.quobyte',
+                                       '--disable-xattrs',
                                        quobyte_volume,
                                        export_mnt_base,
                                        '-c',
-                                       config_file_dummy,
-                                       check_exit_code=[0, 4])
+                                       config_file_dummy)
                              ]
         mock_execute.assert_has_calls(expected_commands)
+        mock_exists.assert_called_once_with(" /run/systemd/system")
 
     @mock.patch.object(fileutils, "ensure_tree")
     @mock.patch.object(utils, "execute",
@@ -141,49 +201,91 @@ class QuobyteTestCase(test.NoDBTestCase):
                                  "the Quobyte Volume at %s",
                                  export_mnt_base))
 
-    @mock.patch.object(os, "access", return_value=True)
-    @mock.patch.object(utils, "execute")
-    def test_quobyte_is_valid_volume(self, mock_execute, mock_access):
-        mnt_base = '/mnt'
-        quobyte_volume = '192.168.1.1/volume-00001'
-        export_mnt_base = os.path.join(mnt_base,
-                                       utils.get_hash_str(quobyte_volume))
-
-        quobyte.validate_volume(export_mnt_base)
-
-        mock_execute.assert_called_once_with('getfattr',
-                                             '-n',
-                                             'quobyte.info',
-                                             export_mnt_base)
-
-    @mock.patch.object(utils, "execute",
-                       side_effect=(processutils.
-                                    ProcessExecutionError))
-    def test_quobyte_is_valid_volume_vol_not_valid_volume(self, mock_execute):
-        mnt_base = '/mnt'
-        quobyte_volume = '192.168.1.1/volume-00001'
-        export_mnt_base = os.path.join(mnt_base,
-                                       utils.get_hash_str(quobyte_volume))
-
-        self.assertRaises(exception.NovaException,
-                          quobyte.validate_volume,
-                          export_mnt_base)
-
-    @mock.patch.object(os, "access", return_value=False)
-    @mock.patch.object(utils, "execute",
-                       side_effect=(processutils.
-                                    ProcessExecutionError))
-    def test_quobyte_is_valid_volume_vol_no_valid_access(self,
-                                                         mock_execute,
-                                                         mock_access):
-        mnt_base = '/mnt'
-        quobyte_volume = '192.168.1.1/volume-00001'
-        export_mnt_base = os.path.join(mnt_base,
-                                       utils.get_hash_str(quobyte_volume))
-
-        self.assertRaises(exception.NovaException,
-                          quobyte.validate_volume,
-                          export_mnt_base)
+    @mock.patch.object(psutil, "disk_partitions")
+    @mock.patch.object(os, "stat")
+    def test_validate_volume_all_good(self, stat_mock, part_mock):
+        part_mock.return_value = self.get_mock_partitions()
+        drv = quobyte
+
+        def statMockCall(*args):
+            if args[0] == self.TEST_MNT_POINT:
+                stat_result = mock.Mock()
+                stat_result.st_size = 0
+                return stat_result
+            return os.stat(args)
+        stat_mock.side_effect = statMockCall
+
+        drv.validate_volume(self.TEST_MNT_POINT)
+
+        stat_mock.assert_called_once_with(self.TEST_MNT_POINT)
+        part_mock.assert_called_once_with(all=True)
+
+    @mock.patch.object(psutil, "disk_partitions")
+    @mock.patch.object(os, "stat")
+    def test_validate_volume_mount_not_working(self, stat_mock, part_mock):
+        part_mock.return_value = self.get_mock_partitions()
+        drv = quobyte
+
+        def statMockCall(*args):
+            print (args)
+            if args[0] == self.TEST_MNT_POINT:
+                raise nova_exception.InvalidVolume()
+        stat_mock.side_effect = [os.stat, statMockCall]
+
+        self.assertRaises(
+            excClass=nova_exception.InvalidVolume,
+            callableObj=drv.validate_volume,
+            mount_path=self.TEST_MNT_POINT)
+        stat_mock.assert_called_with(self.TEST_MNT_POINT)
+        part_mock.assert_called_once_with(all=True)
+
+    def test_validate_volume_no_mtab_entry(self):
+        msg = ("No matching Quobyte mount entry for %(mpt)s"
+               " could be found for validation in partition list."
+               % {'mpt': self.TEST_MNT_POINT})
+
+        self.assertRaisesAndMessageMatches(
+            nova_exception.InvalidVolume,
+            msg,
+            quobyte.validate_volume,
+            self.TEST_MNT_POINT)
+
+    @mock.patch.object(psutil, "disk_partitions")
+    def test_validate_volume_wrong_mount_type(self, part_mock):
+        mypart = mock.Mock()
+        mypart.device = "not-quobyte"
+        mypart.mountpoint = self.TEST_MNT_POINT
+        part_mock.return_value = [mypart]
+        msg = ("The mount %(mpt)s is not a valid"
+               " Quobyte volume according to partition list."
+               % {'mpt': self.TEST_MNT_POINT})
+
+        self.assertRaisesAndMessageMatches(
+            nova_exception.InvalidVolume,
+            msg,
+            quobyte.validate_volume,
+            self.TEST_MNT_POINT)
+        part_mock.assert_called_once_with(all=True)
+
+    @mock.patch.object(os, "stat")
+    @mock.patch.object(psutil, "disk_partitions")
+    def test_validate_volume_stale_mount(self, part_mock, stat_mock):
+        part_mock.return_value = self.get_mock_partitions()
+
+        def statMockCall(*args):
+            if args[0] == self.TEST_MNT_POINT:
+                stat_result = mock.Mock()
+                stat_result.st_size = 1
+                return stat_result
+            return os.stat(args)
+        stat_mock.side_effect = statMockCall
+
+        # As this uses a dir size >0, it raises an exception
+        self.assertRaises(
+            nova_exception.InvalidVolume,
+            quobyte.validate_volume,
+            self.TEST_MNT_POINT)
+        part_mock.assert_called_once_with(all=True)
 
 
 class LibvirtQuobyteVolumeDriverTestCase(
@@ -332,12 +434,12 @@ class LibvirtQuobyteVolumeDriverTestCase(
 
         def exe_side_effect(*cmd, **kwargs):
             if cmd == mock.ANY:
-                raise exception.NovaException()
+                raise nova_exception.NovaException()
 
         with mock.patch.object(quobyte,
                                'validate_volume') as mock_execute:
             mock_execute.side_effect = exe_side_effect
-            self.assertRaises(exception.NovaException,
+            self.assertRaises(nova_exception.NovaException,
                               libvirt_driver.connect_volume,
                               connection_info,
                               self.disk_info)
diff --git nova/virt/libvirt/imagebackend.py nova/virt/libvirt/imagebackend.py
index 8dd227e..eaf5c81 100644
--- nova/virt/libvirt/imagebackend.py
+++ nova/virt/libvirt/imagebackend.py
@@ -232,9 +232,11 @@ class Image(object):
             if os.path.exists(base) and size > self.get_disk_size(base):
                 self.resize_image(size)
 
-            if (self.preallocate and self._can_fallocate() and
-                    os.access(self.path, os.W_OK)):
-                utils.execute('fallocate', '-n', '-l', size, self.path)
+            if (self.preallocate and os.access(self.path, os.W_OK)):
+                LOG.debug('Truncating new image at %(path)s to virtual size '
+                          '(patched for Quobyte).',
+                          {'path': self.path})
+                utils.execute('truncate', '-s', size, self.path)
 
     def _can_fallocate(self):
         """Check once per class, whether fallocate(1) is available,
diff --git nova/virt/libvirt/volume/quobyte.py nova/virt/libvirt/volume/quobyte.py
index 284a084..f36aacb 100644
--- nova/virt/libvirt/volume/quobyte.py
+++ nova/virt/libvirt/volume/quobyte.py
@@ -19,6 +19,7 @@ import os
 from oslo_concurrency import processutils
 from oslo_log import log as logging
 from oslo_utils import fileutils
+import psutil
 import six
 
 import nova.conf
@@ -44,15 +45,22 @@ def mount_volume(volume, mnt_base, configfile=None):
     """Wraps execute calls for mounting a Quobyte volume"""
     fileutils.ensure_tree(mnt_base)
 
-    command = ['mount.quobyte', volume, mnt_base]
+    # NOTE(kaisers): disable xattrs to speed up io as this omits
+    # additional metadata requests in the backend. xattrs can be
+    # enabled without issues but will reduce performance.
+    command = ['mount.quobyte', '--disable-xattrs', volume, mnt_base]
+    if os.path.exists(" /run/systemd/system"):
+        # Note(kaisers): with systemd this requires a separate CGROUP to
+        # prevent Nova service stop/restarts from killing the mount.
+        command = ['systemd-run', '--scope', '--user', 'mount.quobyte',
+                   '--disable-xattrs', volume, mnt_base]
     if configfile:
         command.extend(['-c', configfile])
 
     LOG.debug('Mounting volume %s at mount point %s ...',
               volume,
               mnt_base)
-    # Run mount command but do not fail on already mounted exit code
-    utils.execute(*command, check_exit_code=[0, 4])
+    utils.execute(*command)
     LOG.info(_LI('Mounted volume: %s'), volume)
 
 
@@ -69,21 +77,32 @@ def umount_volume(mnt_base):
                           mnt_base)
 
 
-def validate_volume(mnt_base):
-    """Wraps execute calls for checking validity of a Quobyte volume"""
-    command = ['getfattr', "-n", "quobyte.info", mnt_base]
-    try:
-        utils.execute(*command)
-    except processutils.ProcessExecutionError as exc:
-        msg = (_("The mount %(mount_path)s is not a valid"
-                 " Quobyte volume. Error: %(exc)s")
-               % {'mount_path': mnt_base, 'exc': exc})
-        raise nova_exception.InternalError(msg)
-
-    if not os.access(mnt_base, os.W_OK | os.X_OK):
-        msg = (_LE("Volume is not writable. Please broaden the file"
-                   " permissions. Mount: %s") % mnt_base)
-        raise nova_exception.InternalError(msg)
+def validate_volume(mount_path):
+    """Runs a number of tests to be sure this is a (working) Quobyte mount"""
+    partitions = psutil.disk_partitions(all=True)
+    for p in partitions:
+        if mount_path != p.mountpoint:
+            continue
+        if p.device.startswith("quobyte@"):
+            statresult = os.stat(mount_path)
+            # Note(kaisers): Quobyte always shows mount points with size 0
+            if statresult.st_size == 0:
+                # client looks healthy
+                return  # we're happy here
+            else:
+                msg = (_("The mount %(mount_path)s is not a "
+                         "valid Quobyte volume. Stale mount?")
+                       % {'mount_path': mount_path})
+            raise nova_exception.InvalidVolume(msg)
+        else:
+            msg = (_("The mount %(mount_path)s is not a valid"
+                     " Quobyte volume according to partition list.")
+                   % {'mount_path': mount_path})
+            raise nova_exception.InvalidVolume(msg)
+    msg = (_("No matching Quobyte mount entry for %(mount_path)s"
+             " could be found for validation in partition list.")
+           % {'mount_path': mount_path})
+    raise nova_exception.InvalidVolume(msg)
 
 
 class LibvirtQuobyteVolumeDriver(fs.LibvirtBaseFileSystemVolumeDriver):
@@ -106,7 +125,7 @@ class LibvirtQuobyteVolumeDriver(fs.LibvirtBaseFileSystemVolumeDriver):
 
         return conf
 
-    @utils.synchronized('connect_volume')
+    @utils.synchronized('connect_qb_volume')
     def connect_volume(self, connection_info, disk_info):
         """Connect the volume."""
         data = connection_info['data']
@@ -127,12 +146,12 @@ class LibvirtQuobyteVolumeDriver(fs.LibvirtBaseFileSystemVolumeDriver):
 
         if not mounted:
             mount_volume(quobyte_volume,
-                                 mount_path,
-                                 CONF.libvirt.quobyte_client_cfg)
+                         mount_path,
+                         CONF.libvirt.quobyte_client_cfg)
 
         validate_volume(mount_path)
 
-    @utils.synchronized('connect_volume')
+    @utils.synchronized('connect_qb_volume')
     def disconnect_volume(self, connection_info, disk_dev):
         """Disconnect the volume."""
 
diff --git releasenotes/notes/bug_1659328-73686be497f5f85a.yaml releasenotes/notes/bug_1659328-73686be497f5f85a.yaml
new file mode 100644
index 0000000..e55248e
--- /dev/null
+++ releasenotes/notes/bug_1659328-73686be497f5f85a.yaml
@@ -0,0 +1,6 @@
+---
+
+fixes:
+  - |
+    The i/o performance for Quobyte volumes has been increased significantly
+    by disabling xattrs.
